<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>XMvn Graph</title>
<style>
html, body {
  height: 100%;
  margin: 0;
  overflow: hidden; /* prevent page scrollbars */
  display: flex;
  flex-direction: column;
}

#sigma-container {
  flex: 1 1 auto;
  border: 1px solid #ccc; /* optional: to see the bounds */
  overflow: hidden;       /* clip inside container */
}

#topbar {
  flex: 0 0 auto; /* natural height */
}

#topbar {
  display: flex;
  align-items: flex-start;
  gap: 16px;
  padding: 8px 12px;
  background: #f5f5f7;
  border-bottom: 1px solid #e5e5ea;
  font: 14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
}

.left {
  display: flex;
  flex-direction: column;
  gap: 4px;
}

.title {
  font-size: 16px;
  font-weight: 600;
}

.badge {
  padding: 2px 6px;
  border-radius: 10px;
  font-size: 12px;
  background: #eee;
  align-self: flex-start;
}

.center {
  display: flex;
  flex-direction: column;
  gap: 8px;
  flex: 1;
}

#filter-fieldset {
  border: 1px solid #ddd;
  border-radius: 8px;
  padding: 4px 8px;
  min-width: 200px;
}

#filter-fieldset legend {
  padding: 0 6px;
  color: #555;
  font-weight: 500;
}

#log {
  position: absolute;
  bottom: 10px;
  left: 10px;
  width: 320px;
  height: 120px;
  overflow-y: auto;
  font-family: monospace;
  background: rgba(250,250,250,0.95);
  color: #333;
  font-size: 12px;
  padding: 6px 8px;
  border: 1px solid #ddd;
  border-radius: 6px;
  z-index: 1500;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
  display: none; /* hidden by default */
}

.right {
  display: flex;
  flex-direction: column;
  gap: 10px;
}

.layout-controls {
  display: flex;
  gap: 12px;
  align-items: center;
}

.buttons {
  display: flex;
  gap: 8px;
}

button {
  cursor: pointer;
  border: 1px solid #ccc;
  border-radius: 6px;
  background: #fff;
  padding: 4px 10px;
  font-size: 13px;
}

button:hover {
  background: #f0f0f0;
}

.corner-toggle {
  font-size: 13px;
  background: #fff;
  border: 1px solid #ddd;
  border-radius: 6px;
  padding: 2px 6px;
  align-self: flex-start;
}

#tooltip {
  position: absolute;
  background: rgba(0,0,0,0.8);
  color: #fff;
  border-radius: 4px;
  padding: 6px 8px;
  font-size: 20px;
  pointer-events: none;
  display: none;
  z-index: 1000;
}

.relations-panel {
  position: absolute;
  top: 60px;        /* below topbar */
  right: 0;
  width: 280px;
  max-height: 70%;
  overflow-y: auto;
  background: rgba(250,250,250,0.95);
  border-left: 1px solid #ddd;
  padding: 8px;
  font-family: monospace;
  font-size: 13px;
  z-index: 2000;
  box-shadow: -2px 0 4px rgba(0,0,0,0.1);
}

  </style>
</head>
<body>
<div id="topbar">
  <div class="left">
    <strong class="title">XMvn Graph</strong>
    <span class="badge" id="stats">0 nodes • 0 edges</span>
  </div>

  <div class="center">
    <fieldset id="filter-fieldset">
      <legend>Filter</legend>
    </fieldset>
  </div>

  <div class="right">
    <div class="layout-controls">
      <label>
        Layout
        <select id="layout-select">
          <option value="none">None (Manual)</option>
          <option value="random">Randomize</option>
          <option value="circular">Circular</option>
          <option value="pack">Circle Pack</option>
          <option value="fa2" selected>ForceAtlas2</option>
          <option value="noverlap">Noverlap</option>
          <option value="breadth">Breadth Order</option>
          <option value="dag-global">DAG Global</option>
          <option value="dag-selected">DAG Selected Root</option>
        </select>
      </label>
      <label>
        Iterations
        <input type="number" id="iterations" min="1" step="10" value="200">
      </label>
    </div>

    <div class="buttons">
      <button id="run-layout">Run</button>
      <button id="start-loop">Start</button>
      <button id="stop-loop" disabled>Stop</button>
      <button id="reset-camera" title="Reset camera">Reset View</button>
      <button id="toggle-relations">Show Relations</button>
      <button id="toggle-log">Show Log</button>
      <label>
        <input type="checkbox" id="layout-visible-only">
        Layout only visible nodes/edges
      </label>
    </div>

    <div class="options">
      <label class="corner-toggle">
        Tooltip position
        <select id="tooltip-position">
          <option value="node" selected>Near node</option>
          <option value="top-left">Top-left</option>
          <option value="top-right">Top-right</option>
          <option value="bottom-left">Bottom-left</option>
          <option value="bottom-right">Bottom-right</option>
        </select>
      </label>
    </div>
  </div>
</div>
<input type="search" id="search-box" placeholder="Find node…" style="margin-left:12px; padding:4px 6px;">
<div id="sigma-container"></div>
<div id="tooltip"></div>
<div id="log"></div>
<div id="relations" class="relations-panel" style="display:none;"></div>
<script type="importmap">
{
  "imports": {
    "sigma": "https://cdn.jsdelivr.net/npm/sigma@3/+esm",
    "graphology": "https://cdn.jsdelivr.net/npm/graphology@0.25.4/+esm",
    "@sigma/node-image": "https://cdn.jsdelivr.net/npm/@sigma/node-image@3/+esm",
    "@sigma/rendering": "https://cdn.jsdelivr.net/npm/sigma@3/rendering/dist/sigma-rendering.esm.js/+esm",
    "@sigma/utils": "https://cdn.jsdelivr.net/npm/sigma@3/utils/dist/sigma-utils.esm.js/+esm",
    "graphology-layout": "https://cdn.jsdelivr.net/npm/graphology-layout@0.6.1/+esm",
    "graphology-layout-forceatlas2": "https://cdn.jsdelivr.net/npm/graphology-layout-forceatlas2@0.10.1/+esm",
    "graphology-layout-noverlap": "https://cdn.jsdelivr.net/npm/graphology-layout-noverlap@0.4.2/+esm",
    "graphology-dagre": "https://cdn.jsdelivr.net/npm/graphology-dag@0.3.0/+esm",
    "graphology-utils": "https://cdn.jsdelivr.net/npm/graphology-utils@2.5.0/+esm"
  }
}
</script>

<script type="module">
import Sigma from "sigma";
import Graph from "graphology";
import { createNodeImageProgram } from "@sigma/node-image";
import * as rendering from "@sigma/rendering";
//layouts
import { circular, circlepack, random as randomLayout } from "graphology-layout";
import forceAtlas2 from "graphology-layout-forceatlas2";
import noverlap from "graphology-layout-noverlap";
import { topologicalGenerations } from "graphology-dagre";
import { subgraph } from "https://cdn.jsdelivr.net/npm/graphology-operators@1.6.1/+esm";

const ARROW_PRESETS = {
  xslim:    { length: 9.0, wideness: 1.5 },
  slim:     { length: 9.0, wideness: 3.0 },
  balanced: { length: 9.0, wideness: 4.5 },
  fat:      { length: 9.0, wideness: 6.0 },
  radius:   { length: 3.0, wideness: 3.0, useRadius: true }
};
/**
factor - tweak this to make arrowheads longer or wider
*/
function createEdgeArrowScaledProgram(inputOptions = {}, preset = "balanced", factor = 1.0) {
  function createHead(options = {}) {
    const Base = rendering.createEdgeArrowHeadProgram(options);
    return class EdgeArrowHeadScaledProgram extends Base {
      setUniforms(params, info) {
        super.setUniforms(params, info);
        const { gl, uniformLocations } = info;
        const style = ARROW_PRESETS[preset] || ARROW_PRESETS.balanced;

        let length = factor * style.length;
        let wideness = factor * style.wideness;

        if (style.useRadius) {
          // scale with node radius (a_radius comes from processVisibleItem)
          length *= params.sizeRatio;
          wideness *= params.sizeRatio;
        }
        gl.uniform1f(uniformLocations.u_lengthToThicknessRatio, length);
        gl.uniform1f(uniformLocations.u_widenessToThicknessRatio, wideness);
      }
    };
  }
  return rendering.createEdgeCompoundProgram([rendering.createEdgeClampedProgram(inputOptions), createHead(inputOptions)]);
}
const EdgeArrowScaledProgram = createEdgeArrowScaledProgram({});

const state = {
  hoveredNode: null,
  hoveredNeighbors: null,
  isDragging: false,
  lastSelectedNode: null
};
// Color palette for nodes
const NODE_TYPE_COLORS = {
  module:         "#1f77b4",
  subproject:     "#2077A0",
  library:        "#d62728",
  testjar:        "#9467bd",
  srcjar:         "#8c564b",
  docjar:         "#c49c94",
  bom:            "#e377c2",
  pom:            "#bcbd22",
  plugin:         "#ff7f0e",
  extension:      "#17becf",
  tool:           "#9edae5",
  script:         "#dbdb8d",
  config:         "#7f7f7f",
  resource:       "#2ca02c",
  container:      "#393b79",
  distribution:   "#8c6d31",
  npm_module:     "#ffb300",
  py_package:     "#2ca02c",
  crate:          "#d62728",
  go_mod:         "#31a354",
  service:        "#636363",
  parent:         "#7f7f7f",
  sample:         "#f7b6d2",
  test:           "#c5b0d5"
};

// Color palette for edges (scopes/relationships)
const EDGE_TYPE_COLORS = {
  compile:            "#1f77b4",
  runtime:            "#ff7f0e",
  provided:           "#bcbd22",
  system:             "#d62728",
  test:               "#9467bd",
  testCompile:        "#c5b0d5",
  testRuntime:        "#f7b6d2",
  annotationProcessor:"#8c564b",
  import:             "#e377c2",
  optional:           "#c49c94",
  devDependency:      "#17becf",
  peerDependency:     "#8c564b",
  dependencyManagement: "#aec7e8",
  extensionOf:        "#2ca02c",
  packagedWith:       "#ffbb78",
  ci:                 "#7f7f7f",
  cd:                 "#393b79",
  excludes:           "#ff9896",
  rest:               "#98df8a",
  soap:               "#c49c94",
  graphql:            "#bcbd22",
  gwt:                "#f7b6d2",
  calls:              "#ff7f0e",
  uses:               "#9edae5",
  generates:          "#636363",
  publishes:          "#8c6d31",
  subscribes:         "#dbdb8d",
  parent:             "#7f7f7f",
  bom:                "#e377c2",
  project_link:       "#1f77b4"
};

function main() {
  const container = document.getElementById("sigma-container");
  const graph = new Graph();
  DATA.edges = dedupeEdges(DATA.edges);
  assignColors(DATA.nodes, DATA.edges);

  // Ensure every node has random initial coords
  DATA.nodes.forEach(n => {
    if (typeof n.attributes.x !== "number" || n.attributes.x===0)
      n.attributes.x = Math.random() * 10 - 5;
    if (typeof n.attributes.y !== "number"|| n.attributes.y===0)
      n.attributes.y = Math.random() * 10 - 5;
  });

  graph.import(DATA);
  //sample graph
  //graph.addNode("a", { x: 0, y: 0, size: 10, label: "Alex" });
  //graph.addNode("b", { x: 10, y: 10, size: 10, label: "Bill" });
  //graph.addEdge("b", "b", { type: "arrowScaled" });
  setupStats(graph);
  const renderer = new Sigma(graph, container, {
    renderEdgeLabels: true,
    minZoomRatio: 0.1,
    maxZoomRatio: 10,
    nodeProgramClasses: {
      circle: rendering.NodeCircleProgram,
      point: rendering.NodePointProgram,
      image: createNodeImageProgram()
    },
    edgeProgramClasses: {
      arrow: rendering.EdgeArrowProgram,
      clamped: rendering.EdgeClampedProgram,
      doubleArrow: rendering.EdgeDoubleArrowProgram,
      doubleClamped: rendering.EdgeDoubleClampedProgram,
      line: rendering.EdgeLineProgram,
      rectangle: rendering.EdgeRectangleProgram,
      triangle: rendering.EdgeTriangleProgram,
      arrowScaled: EdgeArrowScaledProgram,
      //curved: rendering.EdgeCurveProgram
    },
    defaultEdgeType: "arrowScaled",
  });

  // Kick-start layout
  //const settings = forceAtlas2.inferSettings(graph);
  //forceAtlas2.assign(graph, { iterations: 200, settings:{...settings,gravity:100} });
  //forceAtlas2.assign(graph, { iterations: 200, settings });
  /*
  forceAtlas2.assign(graph, {
    iterations: 1000, // more steps → more stable layout
    settings: {
      ...settings,
      gravity: 1,          // keep nodes centered, not collapsed
      scalingRatio: 10,    // spread them apart
      strongGravityMode: false
    }
  });
  */
  const settings = forceAtlas2.inferSettings(graph);
  /*
  const settings = {
    linLogMode: true,       // better for clustering
    outboundAttractionDistribution: false,
    adjustSizes: true,      // prevent node overlap
    edgeWeightInfluence: 1, // respect edge weights
    scalingRatio: 10,       // how far apart clusters spread (default 1 → too tight)
    strongGravityMode: false,
    gravity: 1,             // mild central pull
    slowDown: 1             // increase if layout jumps too fast
  };
  */

  forceAtlas2.assign(graph, {
    iterations: 200, // more steps for stability
    settings: {
      ...settings,
      //scalingRatio: 10,       // how far apart clusters spread (default 1 → too tight)
      //strongGravityMode: false,
      //gravity: 1,             // mild central pull
      //linLogMode: true,
    }
  });
  //renderer.refresh();
  //renderer.getCamera().animatedReset({ duration: 300 }); // reset view to fit

  renderer.refresh();
  setupTooltips(graph, renderer);
  setupHoverHighlight(graph, renderer);
  setupCamera(renderer);
  setupNodeDragging(renderer, graph);
  setupLogPanel();
  setupFilters(graph);
  setupSearch(graph, renderer);
  setupRelationsPanel();
  setupSelection(graph, renderer);
  setupLayouts(graph, renderer);
  console.log("rendering finished");
}

function assignColors(nodes, edges) {
  nodes.forEach(n => {
    const type = n.attributes?.meta?.nodeType;
    if (type && NODE_TYPE_COLORS[type] && !n.attributes.color)
      n.attributes.color = NODE_TYPE_COLORS[type];
  });
  edges.forEach(e => {
    let t = e.meta?.edgeType || e.meta?.scope;
    if (t && EDGE_TYPE_COLORS[t] && !e.attributes.color)
      e.attributes.color = EDGE_TYPE_COLORS[t];
  });
}
function dedupeEdges(edges) {
  const seen = new Set();
  return edges.filter(e => {
    const key = e.source + "->" + e.target;
    if (seen.has(key)) {
      console.warn(`[dedupe] Duplicate edge ignored: ${key}`);
      return false;
    }
    seen.add(key);
    return true;
  });
}

function setupTooltips(graph, renderer) {
  const container = renderer.getContainer();
  const tooltip = document.getElementById("tooltip");  // now from template
  const tooltipSelect = document.getElementById("tooltip-position"); // dropdown if you keep it

  renderer.on("enterNode", ({ node }) => {
    const meta = graph.getNodeAttribute(node, "meta") || {};
    const label = graph.getNodeAttribute(node, "label");
    tooltip.innerHTML =
      "<b>" + label + "</b><br>" +
      Object.entries(meta).map(([k, v]) => k + ": " + v).join("<br>");
    tooltip.style.display = "block";

    positionTooltip(node);
    tooltip.dataset.node = node;
  });

  renderer.on("leaveNode", () => {
    tooltip.style.display = "none";
    delete tooltip.dataset.node;
  });

  renderer.getCamera().on("updated", () => {
    if (tooltip.style.display === "block" && tooltip.dataset.node) {
      positionTooltip(tooltip.dataset.node);
    }
  });

  function positionTooltip(node) {
    const mode = tooltipSelect?.value || "node";
    if (mode === "node") {
      const x = graph.getNodeAttribute(node, "x");
      const y = graph.getNodeAttribute(node, "y");
      const pos = renderer.graphToViewport({ x, y });
      tooltip.style.left = pos.x + 15 + "px";
      tooltip.style.top = pos.y + 15 + "px";
    }
    else if (mode === "top-left") {
      tooltip.style.left = "10px";
      tooltip.style.top = "40px";
    }
    else if (mode === "top-right") {
      tooltip.style.left = container.clientWidth - tooltip.offsetWidth - 10 + "px";
      tooltip.style.top = "40px";
    }
    else if (mode === "bottom-left") {
      tooltip.style.left = "10px";
      tooltip.style.top = container.clientHeight - tooltip.offsetHeight - 10 + "px";
    }
    else if (mode === "bottom-right") {
      tooltip.style.left = container.clientWidth - tooltip.offsetWidth - 10 + "px";
      tooltip.style.top = container.clientHeight - tooltip.offsetHeight - 10 + "px";
    }
  }
}


function setupStats(graph) {
  const statsEl = document.getElementById("stats");
  function updateStats(filteredNodes, filteredEdges) {
    statsEl.textContent = `${filteredNodes} of ${graph.order} nodes • ${filteredEdges} of ${graph.size} edges`;
  }
  // Allow external update
  graph._updateStats = updateStats;
  // Initial, full values
  updateStats(graph.order, graph.size);
}

function setupCamera(renderer) {
  document.getElementById("reset-camera").addEventListener("click", () => {
    renderer.getCamera().animatedReset({ duration: 300 });
  });
}

function setupHoverHighlight(graph, renderer) {
  renderer.setSetting("nodeReducer", (node, data) => {
    if (data.hidden) return data;
    if (state.isDragging) return data;
    if (state.hoveredNode && node !== state.hoveredNode && !state.hoveredNeighbors?.has(node)) {
      return { ...data, color: "#f2f2f2", label: "" };
    }
    return data;
  });

  renderer.setSetting("edgeReducer", (edge, data) => {
    if (data.hidden) return data;
    if (state.isDragging) return data;
    if (state.hoveredNode) {
      const s = graph.source(edge), t = graph.target(edge);
      if (s !== state.hoveredNode && t !== state.hoveredNode) {
        return { ...data, hidden: true };
      }
    }
    return data;
  });

  renderer.on("enterNode", ({ node }) => {
    if (state.isDragging) return;
    state.hoveredNode = node;
    state.hoveredNeighbors = new Set(graph.neighbors(node));
    renderer.refresh({ skipIndexation: true });
  });
  renderer.on("leaveNode", () => {
    if (state.isDragging) return;
    state.hoveredNode = null;
    state.hoveredNeighbors = null;
    renderer.refresh({ skipIndexation: true });
  });
}

function setupNodeDragging(renderer, graph) {
  let draggedNode = null;
  let dragOffset = { x: 0, y: 0 };

  renderer.on("downNode", ({ node, event }) => {
    state.isDragging = true;
    state.hoveredNode = null;
    state.hoveredNeighbors = null;
    renderer.refresh({ skipIndexation: true });
    draggedNode = node;
    const attrs = graph.getNodeAttributes(node);
    const rect = renderer.getContainer().getBoundingClientRect();
    const mx = event.original.clientX - rect.left;
    const my = event.original.clientY - rect.top;
    const { x: nodeX, y: nodeY } = renderer.viewportToGraph({ x: mx, y: my });
    dragOffset.x = attrs.x - nodeX;
    dragOffset.y = attrs.y - nodeY;
    event.preventSigmaDefault = true;
    if (event.original) {
      event.original.preventDefault();
      event.original.stopPropagation();
    }
  });

  function handleMove(e) {
    if (!state.isDragging || !draggedNode) return;
    e.preventDefault();
    e.stopPropagation();
    const rect = renderer.getContainer().getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;
    const { x, y } = renderer.viewportToGraph({ x: mx, y: my });
    graph.setNodeAttribute(draggedNode, "x", x + dragOffset.x);
    graph.setNodeAttribute(draggedNode, "y", y + dragOffset.y);
  }

  function handleUp(e) {
    if (state.isDragging) {
      state.isDragging = false;
      draggedNode = null;
      dragOffset = { x: 0, y: 0 };
      e.preventDefault();
      e.stopPropagation();
      const evt = new MouseEvent("mouseup", { bubbles: true, cancelable: true, view: window });
      renderer.getContainer().dispatchEvent(evt);
      renderer.refresh({ skipIndexation: true });
    }
  }

  renderer.getContainer().addEventListener("mousemove", handleMove, { passive: false });
  renderer.getContainer().addEventListener("mouseup", handleUp, { passive: false });
  renderer.getContainer().addEventListener("mouseleave", handleUp, { passive: false });
}

function breadthLayout(graph, rootNode) {
  const visited = new Set([rootNode]);
  const levels = {};
  const queue = [{ node: rootNode, depth: 0 }];

  while (queue.length) {
    const { node, depth } = queue.shift();
    if (!levels[depth]) levels[depth] = [];
    levels[depth].push(node);

    // Save depth marker
    graph.setNodeAttribute(node, "depth", depth);

    // Ensure we always have a base label stored
    const currentLabel = graph.getNodeAttribute(node, "label");
    const baseLabel = graph.getNodeAttribute(node, "baseLabel") || currentLabel;
    graph.setNodeAttribute(node, "baseLabel", baseLabel);

    // Reset label to base + depth
    graph.setNodeAttribute(node, "label", `${baseLabel} [${depth}]`);

    // Outgoing → positive depth
    graph.forEachOutboundNeighbor(node, (nbr) => {
      if (!visited.has(nbr)) {
        visited.add(nbr);
        queue.push({ node: nbr, depth: depth + 1 });
      }
    });

    // Incoming → negative depth
    graph.forEachInboundNeighbor(node, (nbr) => {
      if (!visited.has(nbr)) {
        visited.add(nbr);
        queue.push({ node: nbr, depth: depth - 1 });
      }
    });
  }

  const xGap = 200;
  const yGap = 120;

  Object.entries(levels).forEach(([depthStr, nodes]) => {
    const depth = parseInt(depthStr, 10);
    const total = nodes.length;
    nodes.forEach((n, i) => {
      const x = (i - (total - 1) / 2) * xGap;
      const y = depth * yGap;
      graph.setNodeAttribute(n, "x", x);
      graph.setNodeAttribute(n, "y", y);
    });
  });

  // Root override
  graph.setNodeAttribute(rootNode, "x", 0);
  graph.setNodeAttribute(rootNode, "y", 0);
  graph.setNodeAttribute(rootNode, "depth", 0);
}

function dagGlobalLayout(graph, { xGap, yGap, markDepth }) {
  const onlyVisible = layoutVisibleOnly();
  const generations = topologicalGenerations(graph);

  generations.forEach((nodes, depth) => {
    const workingNodes = onlyVisible
      ? nodes.filter(n => !graph.getNodeAttribute(n, "hidden"))
      : nodes;

    const total = workingNodes.length;
    workingNodes.forEach((n, i) => {
      const x = (i - (total - 1) / 2) * xGap;
      const y = depth * yGap;
      graph.setNodeAttribute(n, "x", x);
      graph.setNodeAttribute(n, "y", y);

      if (markDepth) {
        const base = graph.getNodeAttribute(n, "baseLabel") || graph.getNodeAttribute(n, "label");
        graph.setNodeAttribute(n, "label", `${base} [${depth}]`);
      }
    });
  });
}

function dagSelectedLayout(graph, rootNode, { xGap, yGap, markDepth }) {
  if (!rootNode) {
    console.warn("[dagSelectedLayout] No root node provided.");
    return;
  }
  const onlyVisible = layoutVisibleOnly();

  const visited = new Set();
  const levels = new Map();
  const queue = [{ node: rootNode, depth: 0 }];
  visited.add(rootNode);
  levels.set(rootNode, 0);

  while (queue.length) {
    const { node, depth } = queue.shift();
    graph.forEachEdge((edge, attrs, source, target) => {
      if (source === node || target === node) {
        const nbr = source === node ? target : source;
        const dir = source === node ? +1 : -1;
        const newDepth = depth + dir;

        if (
          !levels.has(nbr) ||
          (dir > 0 && newDepth > levels.get(nbr)) ||
          (dir < 0 && newDepth < levels.get(nbr))
        ) {
          levels.set(nbr, newDepth);
          if (!visited.has(nbr)) {
            visited.add(nbr);
            queue.push({ node: nbr, depth: newDepth });
          }
        }
      }
    });
  }

  const grouped = {};
  levels.forEach((d, n) => {
    grouped[d] ??= [];
    grouped[d].push(n);
  });

  Object.entries(grouped).forEach(([depth, nodes]) => {
    const workingNodes = onlyVisible
      ? nodes.filter(n => !graph.getNodeAttribute(n, "hidden"))
      : nodes;

    const total = workingNodes.length;
    workingNodes.forEach((n, i) => {
      const x = (i - (total - 1) / 2) * xGap;
      const y = depth * yGap;

      graph.setNodeAttribute(n, "x", x);
      graph.setNodeAttribute(n, "y", y);

      if (markDepth) {
        const base = graph.getNodeAttribute(n, "baseLabel") || graph.getNodeAttribute(n, "label");
        graph.setNodeAttribute(n, "label", `${base} [${depth}]`);
      }
    });
  });
}


function restoreBaseLabels(graph) {
  graph.forEachNode(n => {
    let base = graph.getNodeAttribute(n, "baseLabel");
    if (!base) {
      // first time we see this node, take whatever label it has now as baseline
      base = graph.getNodeAttribute(n, "label");
      graph.setNodeAttribute(n, "baseLabel", base);
    }
    graph.setNodeAttribute(n, "label", base);
  });
}

function setupLayouts(graph, renderer) {
  const $ = (id) => document.getElementById(id);
  const layoutSelect = $("layout-select");
  const iterationsInput = $("iterations");
  const runBtn = $("run-layout");
  const startBtn = $("start-loop");
  const stopBtn = $("stop-loop");
  let loopHandle = null;

  function runOnce() {
    const mode = layoutSelect.value;
    const iters = Math.max(1, parseInt(iterationsInput.value || "1", 10));
    restoreBaseLabels(graph);

    if (mode === "none") return;

    if (mode === "random") {
      randomLayout.assign(graph);
    } else if (mode === "circular") {
      circular.assign(graph);
    } else if (mode === "circlepack") {
      circlepack.assign(graph);
    } else if (mode === "fa2") {
      runForceAtlas2Layout(graph, iters)
    } else if (mode === "noverlap") {
      noverlap.assign(graph, { margin: 5 });
    } else if (mode === "breadth") {
      const root = state.lastSelectedNode || graph.nodes()[0];
      breadthLayout(graph, root);
    } else if (mode === "dag-global") {
      dagGlobalLayout(graph, { xGap: 200, yGap: 120, markDepth: true });
    } else if (mode === "dag-selected") {
      dagSelectedLayout(graph, state.lastSelectedNode, { xGap: 200, yGap: 120, markDepth: true });
    }
    renderer.refresh();
  }

  runBtn.addEventListener("click", runOnce);

  startBtn.addEventListener("click", () => {
    if (loopHandle) return;
    const tick = () => {
      if (layoutSelect.value !== "fa2") return;
      const settings = forceAtlas2.inferSettings(graph);
      forceAtlas2.assign(graph, { iterations: 10, settings });
    };
    loopHandle = setInterval(tick, 30);
    startBtn.disabled = true; stopBtn.disabled = false;
  });

  stopBtn.addEventListener("click", () => {
    if (loopHandle) clearInterval(loopHandle);
    loopHandle = null;
    startBtn.disabled = false; stopBtn.disabled = true;
  });
  layoutSelect.addEventListener("change", () => {
    if (loopHandle) stopBtn.click();
    runOnce();
  });
}

function runForceAtlas2Layout(graph, iterations = 200) {
  if (!layoutVisibleOnly()) {
    forceAtlas2.assign(graph, {
      iterations,
      settings: forceAtlas2.inferSettings(graph)
    });
    return;
  }

  // Collect visible nodes
  const visible = [];
  graph.forEachNode(n => {
    if (!graph.getNodeAttribute(n, "hidden")) visible.push(n);
  });

  // Subgraph of visible nodes
  const g2 = subgraph(graph, visible);

  // Layout only visible subgraph
  forceAtlas2.assign(g2, {
    iterations,
    settings: forceAtlas2.inferSettings(g2)
  });

  // Copy positions back
  g2.forEachNode((n, attrs) => {
    graph.setNodeAttribute(n, "x", attrs.x);
    graph.setNodeAttribute(n, "y", attrs.y);
  });

  logMsg("relayout ForceAtlas2 on visible nodes (" + visible.length + ")");
}

function setupSearch(graph, renderer) {
  document.addEventListener("keydown", e => {
    if (e.ctrlKey && e.key.toLowerCase() === "f") {
      e.preventDefault();
      document.getElementById("search-box").focus();
    }
  });

  const searchBox = document.getElementById("search-box");

  // Highlighted nodes
  renderer.setSetting("nodeReducer", (node, data) => {
    const out = { ...data };
    if (graph.getNodeAttribute(node, "highlighted")) {
      out.color = "#ff4136";
      out.size = data.size * 1.5;
    }
    if (graph.getNodeAttribute(node, "selected")) {
      out.color = "#0074D9";
      out.size = data.size * 2.0;
    }
    return out;
  });

  // Listen to typing
  searchBox.addEventListener("input", () => {
    const q = searchBox.value.toLowerCase();
    graph.forEachNode(node => {
      const label = graph.getNodeAttribute(node, "label").toLowerCase();
      graph.setNodeAttribute(node, "highlighted", !!q && label.includes(q));
    });
    renderer.refresh();
  });
}

function setupSelection(graph, renderer) {
  let selectedNodes = new Set();

  renderer.on("clickNode", ({ node, event }) => {
    state.lastSelectedNode = node;
    if (event.original.ctrlKey) {
      if (selectedNodes.has(node)) {
        selectedNodes.delete(node);
        graph.setNodeAttribute(node, "selected", false);
      } else {
        selectedNodes.add(node);
        graph.setNodeAttribute(node, "selected", true);
      }
    } else {
      // reset selection
      selectedNodes.forEach(n => graph.setNodeAttribute(n, "selected", false));
      selectedNodes.clear();
      selectedNodes.add(node);
      graph.setNodeAttribute(node, "selected", true);
    }
    updateRelations(selectedNodes, graph);
    renderer.refresh();
  });
}

function setupLogPanel() {
  const logPanel = document.getElementById("log");
  const toggleBtn = document.getElementById("toggle-log");

  toggleBtn.addEventListener("click", () => {
    logPanel.style.display =
      logPanel.style.display === "none" ? "block" : "none";
  });
}

function setupRelationsPanel() {
  const panel = document.getElementById("relations");
  const toggleBtn = document.getElementById("toggle-relations");

  toggleBtn.addEventListener("click", () => {
    panel.style.display =
      panel.style.display === "none" ? "block" : "none";
  });
}
function logMsg(msg) {
  const logPanel = document.getElementById("log");
  if (!logPanel || logPanel.style.display === "none") return;
  logPanel.innerHTML += msg + "<br/>";
  logPanel.scrollTop = logPanel.scrollHeight;
}

function updateRelations(sel, graph) {
  const panel = document.getElementById("relations");
  if (!panel || panel.style.display === "none") return;

  const lines = [];
  sel.forEach(n => {
    graph.forEachNeighbor(n, nb => {
      const edges = graph.edges(n, nb);
      edges.forEach(eid => {
        const scope =
          graph.getEdgeAttribute(eid, "label") ||
          graph.getEdgeAttribute(eid, "meta")?.edgeType || "";
        lines.push(
          `${scope}: ${graph.getNodeAttribute(n, "label")} -> ${graph.getNodeAttribute(nb, "label")}`
        );
      });
    });
  });

  panel.innerHTML = lines.length
    ? "<pre>" + lines.join("\n") + "</pre>"
    : "<i>No relations</i>";
}

function layoutVisibleOnly() {
  return document.getElementById("layout-visible-only")?.checked;
}

// --- helpers used by setupFilters ---
function safeId(s) {
  // ID-safe (no spaces/quotes/colons etc.)
  return String(s).replace(/[^a-zA-Z0-9_-]/g, "_");
}

function collectAttributeStats(graph) {
  // Exclude these from the Attributes section:
  const excluded = new Set(["groupId", "artifactId", "version", "x", "y", "nodeType", "edgeType"]);

  const nodeKeys = new Set();
  const edgeKeys = new Set();
  const nodeStats = {};
  const edgeStats = {};

  // Discover attribute keys (under attrs.meta) seen anywhere:
  graph.forEachNode((n, attrs) => {
    const meta = attrs.meta || {};
    Object.keys(meta).forEach(k => { if (!excluded.has(k)) nodeKeys.add(k); });
  });
  graph.forEachEdge((e, attrs) => {
    const meta = attrs.meta || {};
    Object.keys(meta).forEach(k => { if (!excluded.has(k)) edgeKeys.add(k); });
  });

  // Count values, including "null" for missing keys:
  graph.forEachNode((n, attrs) => {
    const meta = attrs.meta || {};
    nodeKeys.forEach(k => {
      const v = meta[k] == null ? "null" : meta[k];
      const key = `${k}:${v}`;
      nodeStats[key] = (nodeStats[key] || 0) + 1;
    });
  });
  graph.forEachEdge((e, attrs) => {
    const meta = attrs.meta || {};
    edgeKeys.forEach(k => {
      const v = meta[k] == null ? "null" : meta[k];
      const key = `${k}:${v}`;
      edgeStats[key] = (edgeStats[key] || 0) + 1;
    });
  });

  return { nodeStats, edgeStats, nodeKeys: Array.from(nodeKeys), edgeKeys: Array.from(edgeKeys) };
}

// --- DROP-IN: complete replacement ---
function setupFilters(graph) {
  const fieldset = document.getElementById("filter-fieldset");

  // Type palettes (already in your code)
  const nodeTypeData = {};
  const edgeTypeData = {};
  graph.forEachNode((_, attrs) => {
    const t = attrs.meta?.nodeType;
    if (t && !nodeTypeData[t]) nodeTypeData[t] = { color: attrs.color || "#888" };
  });
  graph.forEachEdge((_, attrs) => {
    const et = attrs.meta?.edgeType;
    if (et && !edgeTypeData[et]) edgeTypeData[et] = { color: attrs.color || "#aaa" };
  });

  // Attribute stats (with :null)
  const { nodeStats, edgeStats, nodeKeys, edgeKeys } = collectAttributeStats(graph);

  // Helper to render inline checkbox chip
  const chip = (id, label, colorBoxCss = "") => `
    <label style="display:inline-flex;align-items:center;gap:6px;margin:0 10px 6px 0;">
      <input type="checkbox" id="${id}" data-id="${id}" checked>
      ${colorBoxCss ? `<span style="${colorBoxCss}"></span>` : ""}
      <span>${label}</span>
    </label>`;

  // Build inline UI
  const nodeTypesRow = Object.entries(nodeTypeData)
    .map(([type, { color }]) => {
      const id = `f-nodeType-${safeId(type)}`;
      const box = `display:inline-block;width:13px;height:13px;background:${color};border:1px solid #ccc;border-radius:3px;vertical-align:-2px`;
      return chip(id, type, box);
    })
    .join("");

  const edgeTypesRow = Object.entries(edgeTypeData)
    .map(([type, { color }]) => {
      const id = `f-edgeType-${safeId(type)}`;
      const box = `display:inline-block;width:13px;height:13px;background:${color};border:1px solid #ccc;border-radius:3px;vertical-align:-2px`;
      return chip(id, type, box);
    })
    .join("");

  // Sort attributes by key then value, with ":null" last
  const byKeyThenVal = (a, b) => {
    const [ka, va] = a[0].split(":", 2);
    const [kb, vb] = b[0].split(":", 2);
    if (ka !== kb) return ka.localeCompare(kb);
    if (va === "null" && vb !== "null") return 1;
    if (vb === "null" && va !== "null") return -1;
    return String(va).localeCompare(String(vb));
  };

  const nodeAttrsRow = Object.entries(nodeStats)
    .sort(byKeyThenVal)
    .map(([pair, count]) => {
      const id = `f-nodeAttr-${safeId(pair)}`;
      return chip(id, `${pair} (${count})`);
    })
    .join("");

  const edgeAttrsRow = Object.entries(edgeStats)
    .sort(byKeyThenVal)
    .map(([pair, count]) => {
      const id = `f-edgeAttr-${safeId(pair)}`;
      return chip(id, `${pair} (${count})`);
    })
    .join("");

  // Render everything (inline / compact)
  fieldset.innerHTML = `
    <legend>Filter</legend>

    <div style="margin-bottom:6px;display:flex;flex-wrap:wrap;align-items:center;">
      <b style="margin-right:8px;">Nodes:</b>
      ${nodeTypesRow || `<i style="color:#777">No node types</i>`}
      <b style="margin:0 8px 0 16px;">Attrs:</b>
      ${nodeAttrsRow || `<i style="color:#777">No node attributes</i>`}
    </div>

    <div style="display:flex;flex-wrap:wrap;align-items:center;">
      <b style="margin-right:8px;">Edges:</b>
      ${edgeTypesRow || `<i style="color:#777">No edge types</i>`}
      <b style="margin:0 8px 0 16px;">Attrs:</b>
      ${edgeAttrsRow || `<i style="color:#777">No edge attributes</i>`}
    </div>
  `;

  // Build lookups from DOM state on demand
  const getAllowedSets = () => {
    const allowedNodeTypes = new Set();
    const allowedEdgeTypes = new Set();
    const allowedNodePairs = new Set(); // e.g. "buildTool:gradle", "buildTool:null"
    const allowedEdgePairs = new Set();

    // types
    fieldset.querySelectorAll('input[id^="f-nodeType-"]').forEach(cb => {
      if (cb.checked) allowedNodeTypes.add(cb.id.replace(/^f-nodeType-/, "").replace(/_/g, " "));
    });
    fieldset.querySelectorAll('input[id^="f-edgeType-"]').forEach(cb => {
      if (cb.checked) allowedEdgeTypes.add(cb.id.replace(/^f-edgeType-/, "").replace(/_/g, " "));
    });

    // attrs
    fieldset.querySelectorAll('input[id^="f-nodeAttr-"]').forEach(cb => {
      if (cb.checked) {
        const raw = cb.id.replace(/^f-nodeAttr-/, "");
        // reverse safeId: we replaced non [a-zA-Z0-9_-] with _; we cannot perfectly reverse.
        // But we still have the readable label next to it; to avoid ambiguity, store the real value as data-pair:
        // (we’ll attach data-pair below just before returning)
      }
    });
    fieldset.querySelectorAll('input[id^="f-edgeAttr-"]').forEach(cb => {
      if (cb.checked) { /* same note as above */ }
    });

    // Because safe->raw isn’t reversible 100%, we store the real pair in dataset:
    fieldset.querySelectorAll('input[id^="f-nodeAttr-"]').forEach(cb => {
      const pair = cb.dataset.pair;
      if (cb.checked && pair) allowedNodePairs.add(pair);
    });
    fieldset.querySelectorAll('input[id^="f-edgeAttr-"]').forEach(cb => {
      const pair = cb.dataset.pair;
      if (cb.checked && pair) allowedEdgePairs.add(pair);
    });

    return { allowedNodeTypes, allowedEdgeTypes, allowedNodePairs, allowedEdgePairs };
  };

  // Attach REAL pair value into dataset (so we don’t rely on ID decoding)
  fieldset.querySelectorAll('input[id^="f-nodeAttr-"]').forEach(cb => {
    const label = cb.parentElement?.querySelector("span:last-child")?.textContent || "";
    const pair = label.replace(/\s*\(\d+\)\s*$/, ""); // drop " (count)"
    cb.dataset.pair = pair;
  });
  fieldset.querySelectorAll('input[id^="f-edgeAttr-"]').forEach(cb => {
    const label = cb.parentElement?.querySelector("span:last-child")?.textContent || "";
    const pair = label.replace(/\s*\(\d+\)\s*$/, "");
    cb.dataset.pair = pair;
  });

  // Visibility checks
  function nodeMatches(attrs, sets) {
    const meta = attrs.meta || {};
    const t = meta.nodeType;

    // Type gate: if a type is present in the UI and is unchecked → hide
    if (t && Object.prototype.hasOwnProperty.call(nodeTypeData, t) && !sets.allowedNodeTypes.has(t)) return false;

    // Attributes: build the node's pairs over the discovered keys (so nulls apply)
    for (const k of nodeKeys) {
      const v = meta[k] == null ? "null" : meta[k];
      const pair = `${k}:${v}`;
      // If that pair exists in the UI and is NOT checked → hide
      if (Object.prototype.hasOwnProperty.call(nodeStats, pair) && !sets.allowedNodePairs.has(pair)) return false;
    }
    return true;
  }

  function edgeMatches(attrs, s, t, sets) {
    const meta = attrs.meta || {};
    const et = meta.edgeType;

    if (et && Object.prototype.hasOwnProperty.call(edgeTypeData, et) && !sets.allowedEdgeTypes.has(et)) return false;

    for (const k of edgeKeys) {
      const v = meta[k] == null ? "null" : meta[k];
      const pair = `${k}:${v}`;
      if (Object.prototype.hasOwnProperty.call(edgeStats, pair) && !sets.allowedEdgePairs.has(pair)) return false;
    }

    // also ensure both endpoints are visible
    const srcHidden = graph.getNodeAttribute(s, "hidden") === true;
    const tgtHidden = graph.getNodeAttribute(t, "hidden") === true;
    return !srcHidden && !tgtHidden;
  }

  function applyFilters() {
    const sets = getAllowedSets();

    let shownNodes = 0, shownEdges = 0;

    // Nodes
    graph.forEachNode((n, attrs) => {
      const visible = nodeMatches(attrs, sets);
      graph.setNodeAttribute(n, "hidden", !visible);
      if (visible) shownNodes++;
    });

    // Edges (respect hidden endpoints)
    graph.forEachEdge((e, attrs, s, t) => {
      const visible = edgeMatches(attrs, s, t, sets);
      graph.setEdgeAttribute(e, "hidden", !visible);
      if (visible) shownEdges++;
    });

    // Update badge & maybe re-run FA2 on visible-only
    if (typeof graph._updateStats === "function") graph._updateStats(shownNodes, shownEdges);

    if (document.getElementById("layout-select")?.value === "fa2") {
      runForceAtlas2Layout(graph, parseInt(document.getElementById("iterations").value, 10) || 200);
    }
  }

  // One event listener for all checkboxes (event delegation FTW)
  fieldset.addEventListener("change", (e) => {
    if (e.target && e.target.matches('input[type="checkbox"]')) applyFilters();
  });

  // Initial pass
  applyFilters();
}

const DATA =
/* XMVN_DATA_START */
{
  "attributes": { "name": "Build Tool Graph Example" },
  "nodes": [
    // Modules & Subprojects
    { "key": "mod_app",   "attributes": { "label": "app",   "x": 0,  "y": 0,   "size": 10, "color": "#1f77b4", "meta": { "nodeType": "module", "buildTool": "maven" } } },
    { "key": "mod_core",  "attributes": { "label": "core",  "x": 30, "y": -20, "size": 9,  "color": "#2ca02c", "meta": { "nodeType": "module", "buildTool": "gradle" } } },
    { "key": "subproj_ui","attributes": { "label": "ui",    "x": -30,"y": -10, "size": 8,  "color": "#ff7f0e", "meta": { "nodeType": "subproject", "buildTool": "make" } } },

    // Libraries
    { "key": "lib_guava", "attributes": { "label": "guava", "x": 45, "y": 10,  "size": 7,  "color": "#d62728", "meta": { "nodeType": "library", "artifactType": "jar" } } },
    { "key": "lib_log4j", "attributes": { "label": "log4j", "x": 40, "y": -30, "size": 7,  "color": "#9467bd", "meta": { "nodeType": "library", "artifactType": "jar" } } },

    // Special Jars
    { "key": "testjar",   "attributes": { "label": "app-tests", "x": 0, "y": 40, "size": 6, "color": "#e377c2", "meta": { "nodeType": "testjar" } } },
    { "key": "srcjar",    "attributes": { "label": "app-src",   "x": 0, "y": 55, "size": 6, "color": "#17becf", "meta": { "nodeType": "srcjar" } } },
    { "key": "docjar",    "attributes": { "label": "app-docs",  "x": 0, "y": 70, "size": 6, "color": "#bcbd22", "meta": { "nodeType": "docjar" } } },

    // BOM, POM, ZIP, Docker, WAR, EAR
    { "key": "bom_spring", "attributes": { "label": "spring-bom", "x": -50, "y": -20, "size": 6, "color": "#e377c2", "meta": { "nodeType": "bom" } } },
    { "key": "pom_parent", "attributes": { "label": "parent-pom", "x": -40, "y": 15,  "size": 6, "color": "#7f7f7f", "meta": { "nodeType": "pom" } } },
    { "key": "zip_dist",   "attributes": { "label": "dist.zip",   "x": 20,  "y": 60,  "size": 6, "color": "#8c564b", "meta": { "nodeType": "zip" } } },
    { "key": "docker_img", "attributes": { "label": "app:docker", "x": 30,  "y": 75,  "size": 8, "color": "#00bfff", "meta": { "nodeType": "docker" } } },
    { "key": "war_app",    "attributes": { "label": "webapp.war", "x": -10, "y": 60,  "size": 7, "color": "#ff1493", "meta": { "nodeType": "war" } } },
    { "key": "ear_app",    "attributes": { "label": "enterprise.ear", "x": -25, "y": 75, "size": 7, "color": "#f39c12", "meta": { "nodeType": "ear" } } }
  ],
  "edges": [
    // Standard Maven/Gradle scopes
    { "key": "app_core", "source": "mod_app", "target": "mod_core", "attributes": { "size": 1.5, "color": "#1f77b4" }, "meta": { "edgeType": "compile", "scope": "compile" } },
    { "key": "core_guava", "source": "mod_core", "target": "lib_guava", "attributes": { "size": 1, "color": "#d62728" }, "meta": { "edgeType": "runtime", "scope": "runtime" } },
    { "key": "app_log4j",  "source": "mod_app", "target": "lib_log4j", "attributes": { "size": 1, "color": "#9467bd" }, "meta": { "edgeType": "provided", "scope": "provided" } },
    { "key": "core_testjar", "source": "mod_core", "target": "testjar", "attributes": { "size": 1, "color": "#e377c2" }, "meta": { "edgeType": "test", "scope": "test" } },
    { "key": "core_srcjar",  "source": "mod_core", "target": "srcjar", "attributes": { "size": 1, "color": "#17becf" }, "meta": { "edgeType": "system", "scope": "system" } },
    { "key": "core_docjar",  "source": "mod_core", "target": "docjar", "attributes": { "size": 1, "color": "#bcbd22" }, "meta": { "edgeType": "doc", "scope": "doc" } },
    { "key": "app_subproj_ui", "source": "mod_app", "target": "subproj_ui", "attributes": { "size": 1.2, "color": "#ff7f0e" }, "meta": { "edgeType": "testCompile", "scope": "testCompile" } },
    { "key": "app_bom_spring", "source": "mod_app", "target": "bom_spring", "attributes": { "size": 1, "color": "#e377c2" }, "meta": { "edgeType": "bom-import" } },
    { "key": "app_pom_parent", "source": "mod_app", "target": "pom_parent", "attributes": { "size": 1, "color": "#7f7f7f" }, "meta": { "edgeType": "parent" } },

    // Output packaging
    { "key": "app_zip",     "source": "mod_app", "target": "zip_dist",   "attributes": { "size": 1, "color": "#8c564b" }, "meta": { "edgeType": "zip" } },
    { "key": "app_docker",  "source": "mod_app", "target": "docker_img", "attributes": { "size": 1, "color": "#00bfff" }, "meta": { "edgeType": "docker" } },
    { "key": "app_war",     "source": "mod_app", "target": "war_app",    "attributes": { "size": 1, "color": "#ff1493" }, "meta": { "edgeType": "war" } },
    { "key": "app_ear",     "source": "mod_app", "target": "ear_app",    "attributes": { "size": 1, "color": "#f39c12" }, "meta": { "edgeType": "ear" } },

    // Non-Java edges (simulated service calls)
    { "key": "app_rest",    "source": "mod_app", "target": "mod_core",   "attributes": { "size": 2, "color": "#2ecc40", "label": "REST" },    "meta": { "edgeType": "rest-call", "protocol": "rest" } },
    { "key": "app_soap",    "source": "mod_app", "target": "subproj_ui", "attributes": { "size": 2, "color": "#2980b9", "label": "SOAP" },    "meta": { "edgeType": "soap-call", "protocol": "soap" } },
    { "key": "app_graphql", "source": "mod_app", "target": "lib_log4j",  "attributes": { "size": 2, "color": "#fdcb6e", "label": "GraphQL" }, "meta": { "edgeType": "graphql", "protocol": "graphql" } },
    { "key": "app_gwt",     "source": "subproj_ui", "target": "mod_core", "attributes": { "size": 2, "color": "#6c5ce7", "label": "GWT" },    "meta": { "edgeType": "gwt-call", "protocol": "gwt" } }
  ]
}
/* XMVN_DATA_END */;

main();
</script>
</body>
</html>
