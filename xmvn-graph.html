<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>XMvn Graph</title>
  <style>
html, body { height: 100%; margin: 0; }

#topbar {
  display: flex;
  align-items: flex-start;
  gap: 16px;
  padding: 8px 12px;
  background: #f5f5f7;
  border-bottom: 1px solid #e5e5ea;
  font: 14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
}

#sigma-container {
  height: calc(100% - 100px); /* taller topbar now */
}

.left {
  display: flex;
  flex-direction: column;
  gap: 4px;
}

.title {
  font-size: 16px;
  font-weight: 600;
}

.badge {
  padding: 2px 6px;
  border-radius: 10px;
  font-size: 12px;
  background: #eee;
  align-self: flex-start;
}

.center {
  display: flex;
  flex-direction: column;
  gap: 8px;
  flex: 1;
}

#filter-fieldset {
  border: 1px solid #ddd;
  border-radius: 8px;
  padding: 4px 8px;
  min-width: 200px;
}

#filter-fieldset legend {
  padding: 0 6px;
  color: #555;
  font-weight: 500;
}

#log {
  height: 80px;
  overflow-y: auto;
  font-family: monospace;
  background: #fafafa;
  color: #333;
  font-size: 12px;
  padding: 6px 8px;
  border: 1px solid #ddd;
  border-radius: 6px;
}

.right {
  display: flex;
  flex-direction: column;
  gap: 10px;
}

.layout-controls {
  display: flex;
  gap: 12px;
  align-items: center;
}

.buttons {
  display: flex;
  gap: 8px;
}

button {
  cursor: pointer;
  border: 1px solid #ccc;
  border-radius: 6px;
  background: #fff;
  padding: 4px 10px;
  font-size: 13px;
}

button:hover {
  background: #f0f0f0;
}

.corner-toggle {
  font-size: 13px;
  background: #fff;
  border: 1px solid #ddd;
  border-radius: 6px;
  padding: 2px 6px;
  align-self: flex-start;
}

#tooltip {
  position: absolute;
  background: rgba(0,0,0,0.8);
  color: #fff;
  border-radius: 4px;
  padding: 6px 8px;
  font-size: 20px;
  pointer-events: none;
  display: none;
  z-index: 1000;
}
#side-panel {
  position: absolute;
  right: 0;
  top: 52px;  /* below topbar */
  bottom: 0;
  width: 300px;
  overflow: auto;
  background: #fafafa;
  border-left: 1px solid #ddd;
  padding: 8px;
  font-family: monospace;
  font-size: 13px;
}
  </style>
</head>
<body>
<div id="topbar">
  <div class="left">
    <strong class="title">XMvn Graph</strong>
    <span class="badge" id="stats">0 nodes • 0 edges</span>
  </div>

  <div class="center">
    <fieldset id="filter-fieldset">
      <legend>Filter</legend>
    </fieldset>
    <div id="log"></div>
  </div>

  <div class="right">
    <div class="layout-controls">
      <label>
        Layout
        <select id="layout-select">
          <option value="none">None (Manual)</option>
          <option value="random">Randomize</option>
          <option value="fa2" selected>ForceAtlas2</option>
        </select>
      </label>
      <label>
        Iterations
        <input type="number" id="iterations" min="1" step="10" value="200">
      </label>
    </div>

    <div class="buttons">
      <button id="run-layout">Run</button>
      <button id="start-loop">Start</button>
      <button id="stop-loop" disabled>Stop</button>
      <button id="reset-camera" title="Reset camera">Reset View</button>
    </div>

    <div class="options">
      <label class="corner-toggle">
        Tooltip position
        <select id="tooltip-position">
          <option value="node" selected>Near node</option>
          <option value="top-left">Top-left</option>
          <option value="top-right">Top-right</option>
          <option value="bottom-left">Bottom-left</option>
          <option value="bottom-right">Bottom-right</option>
        </select>
      </label>
    </div>
  </div>
</div>
<input type="search" id="search-box" placeholder="Find node…" style="margin-left:12px; padding:4px 6px;">
<div id="sigma-container"></div>
<div id="side-panel">
  <h3>Relations</h3>
  <div id="relations"></div>
</div>
<div id="tooltip"></div>

<script type="importmap">
{
  "imports": {
    "sigma": "https://cdn.jsdelivr.net/npm/sigma@3/+esm",
    "graphology": "https://cdn.jsdelivr.net/npm/graphology@0.25.4/+esm",
    "@sigma/node-image": "https://cdn.jsdelivr.net/npm/@sigma/node-image@3/+esm",
    "@sigma/rendering": "https://cdn.jsdelivr.net/npm/sigma@3/rendering/dist/sigma-rendering.esm.js/+esm",
    "@sigma/utils": "https://cdn.jsdelivr.net/npm/sigma@3/utils/dist/sigma-utils.esm.js/+esm",
    "graphology-layout-forceatlas2": "https://cdn.jsdelivr.net/npm/graphology-layout-forceatlas2@0.10.1/+esm"
  }
}
</script>

<script type="module">
import Sigma from "sigma";
import Graph from "graphology";
import { createNodeImageProgram } from "@sigma/node-image";
import forceAtlas2 from "graphology-layout-forceatlas2";
import * as rendering from "@sigma/rendering";


const ARROW_PRESETS = {
  xslim:    { length: 9.0, wideness: 1.5 },
  slim:     { length: 9.0, wideness: 3.0 },
  balanced: { length: 9.0, wideness: 4.5 },
  fat:      { length: 9.0, wideness: 6.0 },
  radius:   { length: 3.0, wideness: 3.0, useRadius: true }
};
/**
factor - tweak this to make arrowheads longer or wider
*/
function createEdgeArrowScaledProgram(inputOptions = {}, preset = "balanced", factor = 1.0) {
  function createHead(options = {}) {
    const Base = rendering.createEdgeArrowHeadProgram(options);
    return class EdgeArrowHeadScaledProgram extends Base {
      setUniforms(params, info) {
        super.setUniforms(params, info);
        const { gl, uniformLocations } = info;
        const style = ARROW_PRESETS[preset] || ARROW_PRESETS.balanced;

        let length = factor * style.length;
        let wideness = factor * style.wideness;

        if (style.useRadius) {
          // scale with node radius (a_radius comes from processVisibleItem)
          length *= params.sizeRatio;
          wideness *= params.sizeRatio;
        }
        gl.uniform1f(uniformLocations.u_lengthToThicknessRatio, length);
        gl.uniform1f(uniformLocations.u_widenessToThicknessRatio, wideness);
      }
    };
  }
  return rendering.createEdgeCompoundProgram([rendering.createEdgeClampedProgram(inputOptions), createHead(inputOptions)]);
}
const EdgeArrowScaledProgram = createEdgeArrowScaledProgram({});

const state = {
  hoveredNode: null,
  hoveredNeighbors: null,
  isDragging: false
};
// Color palette for nodes
const NODE_TYPE_COLORS = {
  module:         "#1f77b4",
  subproject:     "#2077A0",
  library:        "#d62728",
  testjar:        "#9467bd",
  srcjar:         "#8c564b",
  docjar:         "#c49c94",
  bom:            "#e377c2",
  pom:            "#bcbd22",
  plugin:         "#ff7f0e",
  extension:      "#17becf",
  tool:           "#9edae5",
  script:         "#dbdb8d",
  config:         "#7f7f7f",
  resource:       "#2ca02c",
  container:      "#393b79",
  distribution:   "#8c6d31",
  npm_module:     "#ffb300",
  py_package:     "#2ca02c",
  crate:          "#d62728",
  go_mod:         "#31a354",
  service:        "#636363",
  parent:         "#7f7f7f",
  sample:         "#f7b6d2",
  test:           "#c5b0d5"
};

// Color palette for edges (scopes/relationships)
const EDGE_TYPE_COLORS = {
  compile:            "#1f77b4",
  runtime:            "#ff7f0e",
  provided:           "#bcbd22",
  system:             "#d62728",
  test:               "#9467bd",
  testCompile:        "#c5b0d5",
  testRuntime:        "#f7b6d2",
  annotationProcessor:"#8c564b",
  import:             "#e377c2",
  optional:           "#c49c94",
  devDependency:      "#17becf",
  peerDependency:     "#8c564b",
  dependencyManagement: "#aec7e8",
  extensionOf:        "#2ca02c",
  packagedWith:       "#ffbb78",
  ci:                 "#7f7f7f",
  cd:                 "#393b79",
  excludes:           "#ff9896",
  rest:               "#98df8a",
  soap:               "#c49c94",
  graphql:            "#bcbd22",
  gwt:                "#f7b6d2",
  calls:              "#ff7f0e",
  uses:               "#9edae5",
  generates:          "#636363",
  publishes:          "#8c6d31",
  subscribes:         "#dbdb8d",
  parent:             "#7f7f7f",
  bom:                "#e377c2",
  project_link:       "#1f77b4"
};

function main() {
  const container = document.getElementById("sigma-container");
  const graph = new Graph();
  DATA.edges = dedupeEdges(DATA.edges);
  assignColors(DATA.nodes, DATA.edges);

  // Ensure every node has random initial coords
  DATA.nodes.forEach(n => {
    if (typeof n.attributes.x !== "number" || n.attributes.x===0)
      n.attributes.x = Math.random() * 10 - 5;
    if (typeof n.attributes.y !== "number"|| n.attributes.y===0)
      n.attributes.y = Math.random() * 10 - 5;
  });

  graph.import(DATA);
  //sample graph
  //graph.addNode("a", { x: 0, y: 0, size: 10, label: "Alex" });
  //graph.addNode("b", { x: 10, y: 10, size: 10, label: "Bill" });
  //graph.addEdge("b", "b", { type: "arrowScaled" });
  setupStats(graph);
  const renderer = new Sigma(graph, container, {
    renderEdgeLabels: true,
    minZoomRatio: 0.1,
    maxZoomRatio: 10,
    nodeProgramClasses: {
      circle: rendering.NodeCircleProgram,
      point: rendering.NodePointProgram,
      image: createNodeImageProgram()
    },
    edgeProgramClasses: {
      arrow: rendering.EdgeArrowProgram,
      clamped: rendering.EdgeClampedProgram,
      doubleArrow: rendering.EdgeDoubleArrowProgram,
      doubleClamped: rendering.EdgeDoubleClampedProgram,
      line: rendering.EdgeLineProgram,
      rectangle: rendering.EdgeRectangleProgram,
      triangle: rendering.EdgeTriangleProgram,
      arrowScaled: EdgeArrowScaledProgram,
      //curved: rendering.EdgeCurveProgram
    },
    defaultEdgeType: "arrowScaled",
  });

  // Kick-start layout
  const settings = forceAtlas2.inferSettings(graph);
  forceAtlas2.assign(graph, { iterations: 200, settings });
  renderer.refresh();
  setupTooltips(graph, renderer);
  setupHoverHighlight(graph, renderer);
  setupCamera(renderer);
  setupNodeDragging(renderer, graph);
  setupFilters(graph);
  setupSearch(graph, renderer);
  setupSelection(graph, renderer);
  setupLayouts(graph);
  console.log("rendering finished");
}

function assignColors(nodes, edges) {
  nodes.forEach(n => {
    const type = n.attributes?.meta?.nodeType;
    if (type && NODE_TYPE_COLORS[type] && !n.attributes.color)
      n.attributes.color = NODE_TYPE_COLORS[type];
  });
  edges.forEach(e => {
    let t = e.meta?.edgeType || e.meta?.scope;
    if (t && EDGE_TYPE_COLORS[t] && !e.attributes.color)
      e.attributes.color = EDGE_TYPE_COLORS[t];
  });
}
function dedupeEdges(edges) {
  const seen = new Set();
  return edges.filter(e => {
    const key = e.source + "->" + e.target;
    if (seen.has(key)) {
      console.warn(`[dedupe] Duplicate edge ignored: ${key}`);
      return false;
    }
    seen.add(key);
    return true;
  });
}

function setupTooltips(graph, renderer) {
  const container = renderer.getContainer();
  const tooltip = document.getElementById("tooltip");  // now from template
  const tooltipSelect = document.getElementById("tooltip-position"); // dropdown if you keep it

  renderer.on("enterNode", ({ node }) => {
    const meta = graph.getNodeAttribute(node, "meta") || {};
    const label = graph.getNodeAttribute(node, "label");
    tooltip.innerHTML =
      "<b>" + label + "</b><br>" +
      Object.entries(meta).map(([k, v]) => k + ": " + v).join("<br>");
    tooltip.style.display = "block";

    positionTooltip(node);
    tooltip.dataset.node = node;
  });

  renderer.on("leaveNode", () => {
    tooltip.style.display = "none";
    delete tooltip.dataset.node;
  });

  renderer.getCamera().on("updated", () => {
    if (tooltip.style.display === "block" && tooltip.dataset.node) {
      positionTooltip(tooltip.dataset.node);
    }
  });

  function positionTooltip(node) {
    const mode = tooltipSelect?.value || "node";
    if (mode === "node") {
      const x = graph.getNodeAttribute(node, "x");
      const y = graph.getNodeAttribute(node, "y");
      const pos = renderer.graphToViewport({ x, y });
      tooltip.style.left = pos.x + 15 + "px";
      tooltip.style.top = pos.y + 15 + "px";
    }
    else if (mode === "top-left") {
      tooltip.style.left = "10px";
      tooltip.style.top = "40px";
    }
    else if (mode === "top-right") {
      tooltip.style.left = container.clientWidth - tooltip.offsetWidth - 10 + "px";
      tooltip.style.top = "40px";
    }
    else if (mode === "bottom-left") {
      tooltip.style.left = "10px";
      tooltip.style.top = container.clientHeight - tooltip.offsetHeight - 10 + "px";
    }
    else if (mode === "bottom-right") {
      tooltip.style.left = container.clientWidth - tooltip.offsetWidth - 10 + "px";
      tooltip.style.top = container.clientHeight - tooltip.offsetHeight - 10 + "px";
    }
  }
}


function setupStats(graph) {
  const statsEl = document.getElementById("stats");
  function updateStats(filteredNodes, filteredEdges) {
    statsEl.textContent = `${filteredNodes} of ${graph.order} nodes • ${filteredEdges} of ${graph.size} edges`;
  }
  // Allow external update
  graph._updateStats = updateStats;
  // Initial, full values
  updateStats(graph.order, graph.size);
}

function setupFilters(graph) {
  const filterFieldset = document.getElementById("filter-fieldset");
  const logEl = document.getElementById("log");

  // Gather unique node and edge types, and one example color for each
  const nodeTypeData = {};
  const edgeTypeData = {};

  graph.forEachNode((_, attrs) => {
    const t = attrs.meta?.nodeType;
    if (t && !nodeTypeData[t]) {
      nodeTypeData[t] = { color: attrs.color || "#888" };
    }
  });
  graph.forEachEdge((_, attrs) => {
    const et = attrs.meta?.edgeType;
    if (et && !edgeTypeData[et]) {
      edgeTypeData[et] = { color: attrs.color || "#aaa" };
    }
  });

  // Build HTML for checkboxes, with colored squares and group labels
  let html = `<legend>Filter</legend>
    <div style="margin-bottom:6px"><b>Nodes:</b> `;
  Object.entries(nodeTypeData).forEach(([type, { color }]) => {
    html += `
      <label style="margin-right: 10px;">
        <input type="checkbox" id="f-node-${type}" checked>
        <span style="display:inline-block;width:13px;height:13px;vertical-align:-2px;background:${color};border-radius:3px;border:1px solid #ccc;margin-right:2px"></span>
        ${type}
      </label>`;
  });
  html += `</div><div><b>Edges:</b> `;
  Object.entries(edgeTypeData).forEach(([type, { color }]) => {
    html += `
      <label style="margin-right: 10px;">
        <input type="checkbox" id="f-edge-${type}" checked>
        <span style="display:inline-block;width:13px;height:13px;vertical-align:-2px;background:${color};border-radius:3px;border:1px solid #ccc;margin-right:2px"></span>
        ${type}
      </label>`;
  });
  html += `</div>`;
  filterFieldset.innerHTML = html;

  // Only now get the elements for event listeners
  const nodeChecks = {};
  const edgeChecks = {};
  Object.keys(nodeTypeData).forEach(type => {
    nodeChecks[type] = document.getElementById(`f-node-${type}`);
  });
  Object.keys(edgeTypeData).forEach(type => {
    edgeChecks[type] = document.getElementById(`f-edge-${type}`);
  });

  function logMsg(msg) {
    if (!logEl) return;
    logEl.innerHTML += msg + "<br/>";
    logEl.scrollTop = logEl.scrollHeight;
  }

  function nodeMatchesFilters(attrs) {
    const t = attrs.meta?.nodeType;
    if (!t) return true;
    return nodeChecks[t]?.checked !== false;
  }
  function edgeMatchesFilters(attrs, s, t) {
    const et = attrs.meta?.edgeType;
    let allowedByType = true;
    if (et) allowedByType = edgeChecks[et]?.checked !== false;
    const srcHidden = graph.getNodeAttribute(s, "hidden") === true;
    const tgtHidden = graph.getNodeAttribute(t, "hidden") === true;
    return allowedByType && !srcHidden && !tgtHidden;
  }
  function applyFilters() {
    let shownNodes = 0, shownEdges = 0;
    graph.forEachNode((n, attrs) => {
      const visible = nodeMatchesFilters(attrs);
      graph.setNodeAttribute(n, "hidden", !visible);
      if (visible) shownNodes++;
    });
    graph.forEachEdge((e, attrs, s, t) => {
      const visible = edgeMatchesFilters(attrs, s, t);
      graph.setEdgeAttribute(e, "hidden", !visible);
      if (visible) shownEdges++;
    });
    const nodeParts = Object.keys(nodeChecks).filter(t => nodeChecks[t].checked);
    const edgeParts = Object.keys(edgeChecks).filter(t => edgeChecks[t].checked);
    const msg = `[${new Date().toLocaleTimeString()}] Filters: nodes [${nodeParts.join(", ")}], edges [${edgeParts.join(", ")}] — ${shownNodes}/${graph.order} nodes, ${shownEdges}/${graph.size} edges shown.`;
    logMsg(msg);
    console.log(msg);
  }

  // Add event listeners to all checkboxes
  Object.values(nodeChecks).forEach(cb => cb.addEventListener("change", applyFilters));
  Object.values(edgeChecks).forEach(cb => cb.addEventListener("change", applyFilters));
  applyFilters();
}


function setupCamera(renderer) {
  document.getElementById("reset-camera").addEventListener("click", () => {
    renderer.getCamera().animatedReset({ duration: 300 });
  });
}

function setupHoverHighlight(graph, renderer) {
  renderer.setSetting("nodeReducer", (node, data) => {
    if (data.hidden) return data;
    if (state.isDragging) return data;
    if (state.hoveredNode && node !== state.hoveredNode && !state.hoveredNeighbors?.has(node)) {
      return { ...data, color: "#f2f2f2", label: "" };
    }
    return data;
  });

  renderer.setSetting("edgeReducer", (edge, data) => {
    if (data.hidden) return data;
    if (state.isDragging) return data;
    if (state.hoveredNode) {
      const s = graph.source(edge), t = graph.target(edge);
      if (s !== state.hoveredNode && t !== state.hoveredNode) {
        return { ...data, hidden: true };
      }
    }
    return data;
  });

  renderer.on("enterNode", ({ node }) => {
    if (state.isDragging) return;
    state.hoveredNode = node;
    state.hoveredNeighbors = new Set(graph.neighbors(node));
    renderer.refresh({ skipIndexation: true });
  });
  renderer.on("leaveNode", () => {
    if (state.isDragging) return;
    state.hoveredNode = null;
    state.hoveredNeighbors = null;
    renderer.refresh({ skipIndexation: true });
  });
}

function setupNodeDragging(renderer, graph) {
  let draggedNode = null;
  let dragOffset = { x: 0, y: 0 };

  renderer.on("downNode", ({ node, event }) => {
    state.isDragging = true;
    state.hoveredNode = null;
    state.hoveredNeighbors = null;
    renderer.refresh({ skipIndexation: true });
    draggedNode = node;
    const attrs = graph.getNodeAttributes(node);
    const rect = renderer.getContainer().getBoundingClientRect();
    const mx = event.original.clientX - rect.left;
    const my = event.original.clientY - rect.top;
    const { x: nodeX, y: nodeY } = renderer.viewportToGraph({ x: mx, y: my });
    dragOffset.x = attrs.x - nodeX;
    dragOffset.y = attrs.y - nodeY;
    event.preventSigmaDefault = true;
    if (event.original) {
      event.original.preventDefault();
      event.original.stopPropagation();
    }
  });

  function handleMove(e) {
    if (!state.isDragging || !draggedNode) return;
    e.preventDefault();
    e.stopPropagation();
    const rect = renderer.getContainer().getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;
    const { x, y } = renderer.viewportToGraph({ x: mx, y: my });
    graph.setNodeAttribute(draggedNode, "x", x + dragOffset.x);
    graph.setNodeAttribute(draggedNode, "y", y + dragOffset.y);
  }

  function handleUp(e) {
    if (state.isDragging) {
      state.isDragging = false;
      draggedNode = null;
      dragOffset = { x: 0, y: 0 };
      e.preventDefault();
      e.stopPropagation();
      const evt = new MouseEvent("mouseup", { bubbles: true, cancelable: true, view: window });
      renderer.getContainer().dispatchEvent(evt);
      renderer.refresh({ skipIndexation: true });
    }
  }

  renderer.getContainer().addEventListener("mousemove", handleMove, { passive: false });
  renderer.getContainer().addEventListener("mouseup", handleUp, { passive: false });
  renderer.getContainer().addEventListener("mouseleave", handleUp, { passive: false });
}

function setupLayouts(graph) {
  const $ = (id) => document.getElementById(id);
  const layoutSelect = $("layout-select");
  const iterationsInput = $("iterations");
  const runBtn = $("run-layout");
  const startBtn = $("start-loop");
  const stopBtn = $("stop-loop");
  let loopHandle = null;

  function randomizePositions() {
    graph.forEachNode((n) => {
      graph.setNodeAttribute(n, "x", (Math.random() - 0.5) * 200);
      graph.setNodeAttribute(n, "y", (Math.random() - 0.5) * 200);
    });
  }
  function runOnce() {
    const mode = layoutSelect.value;
    const iters = Math.max(1, parseInt(iterationsInput.value || "1", 10));
    if (mode === "none") return;
    if (mode === "random") { randomizePositions(); return; }
    if (mode === "fa2") {
      const settings = forceAtlas2.inferSettings(graph);
      forceAtlas2.assign(graph, { iterations: iters, settings });
      return;
    }
  }
  runBtn.addEventListener("click", runOnce);

  startBtn.addEventListener("click", () => {
    if (loopHandle) return;
    const tick = () => {
      if (layoutSelect.value !== "fa2") return;
      const settings = forceAtlas2.inferSettings(graph);
      forceAtlas2.assign(graph, { iterations: 10, settings });
    };
    loopHandle = setInterval(tick, 30);
    startBtn.disabled = true; stopBtn.disabled = false;
  });
  stopBtn.addEventListener("click", () => {
    if (loopHandle) clearInterval(loopHandle);
    loopHandle = null;
    startBtn.disabled = false; stopBtn.disabled = true;
  });
  layoutSelect.addEventListener("change", () => {
    if (loopHandle) stopBtn.click();
  });
}
function setupSearch(graph, renderer) {
  document.addEventListener("keydown", e => {
    if (e.ctrlKey && e.key.toLowerCase() === "f") {
      e.preventDefault();
      document.getElementById("search-box").focus();
    }
  });

  const searchBox = document.getElementById("search-box");

  // Highlighted nodes
  renderer.setSetting("nodeReducer", (node, data) => {
    const out = { ...data };
    if (graph.getNodeAttribute(node, "highlighted")) {
      out.color = "#ff4136";
      out.size = data.size * 1.5;
    }
    if (graph.getNodeAttribute(node, "selected")) {
      out.color = "#0074D9";
      out.size = data.size * 2.0;
    }
    return out;
  });

  // Listen to typing
  searchBox.addEventListener("input", () => {
    const q = searchBox.value.toLowerCase();
    graph.forEachNode(node => {
      const label = graph.getNodeAttribute(node, "label").toLowerCase();
      graph.setNodeAttribute(node, "highlighted", !!q && label.includes(q));
    });
    renderer.refresh();
  });
}

function setupSelection(graph, renderer) {
  let selectedNodes = new Set();

  renderer.on("clickNode", ({ node, event }) => {
    if (event.original.ctrlKey) {
      if (selectedNodes.has(node)) {
        selectedNodes.delete(node);
        graph.setNodeAttribute(node, "selected", false);
      } else {
        selectedNodes.add(node);
        graph.setNodeAttribute(node, "selected", true);
      }
    } else {
      // reset selection
      selectedNodes.forEach(n => graph.setNodeAttribute(n, "selected", false));
      selectedNodes.clear();
      selectedNodes.add(node);
      graph.setNodeAttribute(node, "selected", true);
    }
    updateRelations(selectedNodes);
    renderer.refresh();
  });

  function updateRelations(sel) {
    const panel = document.getElementById("relations");
    const lines = [];
    sel.forEach(n => {
      graph.forEachNeighbor(n, nb => {
        const edge = graph.edge(n, nb);
        const scope = graph.getEdgeAttribute(edge, "label");
        lines.push(`${scope}: ${graph.getNodeAttribute(n,"label")} -> ${graph.getNodeAttribute(nb,"label")}`);
      });
    });
    panel.innerHTML = lines.length ? "<pre>" + lines.join("\n") + "</pre>" : "<i>No relations</i>";
  }
}


const DATA =
/* XMVN_DATA_START */
{
  "attributes": { "name": "Build Tool Graph Example" },
  "nodes": [
    // Modules & Subprojects
    { "key": "mod_app",   "attributes": { "label": "app",   "x": 0,  "y": 0,   "size": 10, "color": "#1f77b4", "meta": { "nodeType": "module", "buildTool": "maven" } } },
    { "key": "mod_core",  "attributes": { "label": "core",  "x": 30, "y": -20, "size": 9,  "color": "#2ca02c", "meta": { "nodeType": "module", "buildTool": "gradle" } } },
    { "key": "subproj_ui","attributes": { "label": "ui",    "x": -30,"y": -10, "size": 8,  "color": "#ff7f0e", "meta": { "nodeType": "subproject", "buildTool": "make" } } },

    // Libraries
    { "key": "lib_guava", "attributes": { "label": "guava", "x": 45, "y": 10,  "size": 7,  "color": "#d62728", "meta": { "nodeType": "library", "artifactType": "jar" } } },
    { "key": "lib_log4j", "attributes": { "label": "log4j", "x": 40, "y": -30, "size": 7,  "color": "#9467bd", "meta": { "nodeType": "library", "artifactType": "jar" } } },

    // Special Jars
    { "key": "testjar",   "attributes": { "label": "app-tests", "x": 0, "y": 40, "size": 6, "color": "#e377c2", "meta": { "nodeType": "testjar" } } },
    { "key": "srcjar",    "attributes": { "label": "app-src",   "x": 0, "y": 55, "size": 6, "color": "#17becf", "meta": { "nodeType": "srcjar" } } },
    { "key": "docjar",    "attributes": { "label": "app-docs",  "x": 0, "y": 70, "size": 6, "color": "#bcbd22", "meta": { "nodeType": "docjar" } } },

    // BOM, POM, ZIP, Docker, WAR, EAR
    { "key": "bom_spring", "attributes": { "label": "spring-bom", "x": -50, "y": -20, "size": 6, "color": "#e377c2", "meta": { "nodeType": "bom" } } },
    { "key": "pom_parent", "attributes": { "label": "parent-pom", "x": -40, "y": 15,  "size": 6, "color": "#7f7f7f", "meta": { "nodeType": "pom" } } },
    { "key": "zip_dist",   "attributes": { "label": "dist.zip",   "x": 20,  "y": 60,  "size": 6, "color": "#8c564b", "meta": { "nodeType": "zip" } } },
    { "key": "docker_img", "attributes": { "label": "app:docker", "x": 30,  "y": 75,  "size": 8, "color": "#00bfff", "meta": { "nodeType": "docker" } } },
    { "key": "war_app",    "attributes": { "label": "webapp.war", "x": -10, "y": 60,  "size": 7, "color": "#ff1493", "meta": { "nodeType": "war" } } },
    { "key": "ear_app",    "attributes": { "label": "enterprise.ear", "x": -25, "y": 75, "size": 7, "color": "#f39c12", "meta": { "nodeType": "ear" } } }
  ],
  "edges": [
    // Standard Maven/Gradle scopes
    { "key": "app_core", "source": "mod_app", "target": "mod_core", "attributes": { "size": 1.5, "color": "#1f77b4" }, "meta": { "edgeType": "compile", "scope": "compile" } },
    { "key": "core_guava", "source": "mod_core", "target": "lib_guava", "attributes": { "size": 1, "color": "#d62728" }, "meta": { "edgeType": "runtime", "scope": "runtime" } },
    { "key": "app_log4j",  "source": "mod_app", "target": "lib_log4j", "attributes": { "size": 1, "color": "#9467bd" }, "meta": { "edgeType": "provided", "scope": "provided" } },
    { "key": "core_testjar", "source": "mod_core", "target": "testjar", "attributes": { "size": 1, "color": "#e377c2" }, "meta": { "edgeType": "test", "scope": "test" } },
    { "key": "core_srcjar",  "source": "mod_core", "target": "srcjar", "attributes": { "size": 1, "color": "#17becf" }, "meta": { "edgeType": "system", "scope": "system" } },
    { "key": "core_docjar",  "source": "mod_core", "target": "docjar", "attributes": { "size": 1, "color": "#bcbd22" }, "meta": { "edgeType": "doc", "scope": "doc" } },
    { "key": "app_subproj_ui", "source": "mod_app", "target": "subproj_ui", "attributes": { "size": 1.2, "color": "#ff7f0e" }, "meta": { "edgeType": "testCompile", "scope": "testCompile" } },
    { "key": "app_bom_spring", "source": "mod_app", "target": "bom_spring", "attributes": { "size": 1, "color": "#e377c2" }, "meta": { "edgeType": "bom-import" } },
    { "key": "app_pom_parent", "source": "mod_app", "target": "pom_parent", "attributes": { "size": 1, "color": "#7f7f7f" }, "meta": { "edgeType": "parent" } },

    // Output packaging
    { "key": "app_zip",     "source": "mod_app", "target": "zip_dist",   "attributes": { "size": 1, "color": "#8c564b" }, "meta": { "edgeType": "zip" } },
    { "key": "app_docker",  "source": "mod_app", "target": "docker_img", "attributes": { "size": 1, "color": "#00bfff" }, "meta": { "edgeType": "docker" } },
    { "key": "app_war",     "source": "mod_app", "target": "war_app",    "attributes": { "size": 1, "color": "#ff1493" }, "meta": { "edgeType": "war" } },
    { "key": "app_ear",     "source": "mod_app", "target": "ear_app",    "attributes": { "size": 1, "color": "#f39c12" }, "meta": { "edgeType": "ear" } },

    // Non-Java edges (simulated service calls)
    { "key": "app_rest",    "source": "mod_app", "target": "mod_core",   "attributes": { "size": 2, "color": "#2ecc40", "label": "REST" },    "meta": { "edgeType": "rest-call", "protocol": "rest" } },
    { "key": "app_soap",    "source": "mod_app", "target": "subproj_ui", "attributes": { "size": 2, "color": "#2980b9", "label": "SOAP" },    "meta": { "edgeType": "soap-call", "protocol": "soap" } },
    { "key": "app_graphql", "source": "mod_app", "target": "lib_log4j",  "attributes": { "size": 2, "color": "#fdcb6e", "label": "GraphQL" }, "meta": { "edgeType": "graphql", "protocol": "graphql" } },
    { "key": "app_gwt",     "source": "subproj_ui", "target": "mod_core", "attributes": { "size": 2, "color": "#6c5ce7", "label": "GWT" },    "meta": { "edgeType": "gwt-call", "protocol": "gwt" } }
  ]
}
/* XMVN_DATA_END */;

main();
</script>
</body>
</html>
